[
  {
    "questionTitle": "说一下Java的特点",
    "questionTips": "思考Java区别于其他编程语言的关键特性",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "编程语言特性"],
    "answer": "主要有以下的特点：\n\n+   **平台无关性**：Java的\"编写一次，运行无处不在\"哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。\n+   **面向对象**：Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类（class）、对象（object）、继承（inheritance）、多态（polymorphism）、抽象（abstraction）和封装（encapsulation）。\n+   **内存管理**：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题。"
  },
  {
    "questionTitle": "Java 的优势和劣势是什么？",
    "questionTips": "分析Java语言在开发过程中的优点和缺点",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "编程语言特性"],
    "answer": "首先，Java的优势，我记得跨平台应该是一个大点，因为JVM的存在，一次编写到处运行。然后面向对象，这个可能也是优势，不过现在很多语言都支持面向对象，但是Java的设计从一开始就是OOP的。还有强大的生态系统，比如Spring框架，Hibernate，各种库和工具，社区支持大，企业应用广泛。另外，内存管理方面，自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好。还有多线程支持，内置的线程机制，方便并发编程。安全性方面，Java有安全模型，比如沙箱机制，适合网络环境。还有稳定性，企业级应用长期使用，版本更新也比较注重向后兼容。\n\n劣势的话，性能可能是一个，虽然JVM优化了很多，但相比C++或者Rust这种原生编译语言，还是有一定开销。特别是启动时间，比如微服务场景下，可能不如Go之类的快。语法繁琐，比如样板代码多，之前没有lambda的时候更麻烦，现在有了但比起Python还是不够简洁。内存消耗，JVM本身占内存，对于资源有限的环境可能不太友好。还有面向对象过于严格，有时候写简单程序反而麻烦，虽然Java8引入了函数式编程，但不如其他语言自然。还有开发效率，相比动态语言如Python，Java需要更多代码，编译过程也可能拖慢开发节奏。"
  },
  {
    "questionTitle": "Java为什么是跨平台的？",
    "questionTips": "理解Java跨平台特性的核心原理",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "JVM", "跨平台"],
    "answer": "Java 能支持跨平台，主要依赖于 JVM 关系比较大。\n\nJVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。\n\n而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一\"中间层\"，就能在不同平台上运行，真正实现了\"一次编译，到处运行\"的目的。\n\nJVM是一个\"桥梁\"，是一个\"中间件\"，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。\n\n编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。\n\n所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。\n\n跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。\n\n![img](https://cdn.xiaolincoding.com//picgo/1713860588639-bb89fc8e-30b6-4d18-a329-f3fea52c729a.png)"
  },
  {
    "questionTitle": "JVM、JDK、JRE三者关系？",
    "questionTips": "区分这三个Java平台核心组件的功能和联系",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "JVM", "JDK", "JRE"],
    "answer": "![image-20240725230247664](https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png)\n\n它们之间的关系如下：\n\n+   JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。\n+   JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。\n+   JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。"
  },
  {
    "questionTitle": "为什么Java解释和编译都有？",
    "questionTips": "思考Java语言执行机制的独特性",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "JVM", "编译原理"],
    "answer": "首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 如下图：\n\n![img](https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp)\n\n**编译性**：\n\n+   Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。\n\n**解释性：**\n\n+   JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。\n\n所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。"
  },
  {
    "questionTitle": "JVM是什么？",
    "questionTips": "理解JVM的核心功能和作用",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "JVM"],
    "answer": "JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。\n\nJVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够\"**一次编译，到处运行的**\"原因。"
  },
  {
    "questionTitle": "编译型语言和解释型语言的区别？",
    "questionTips": "比较两种语言执行方式的不同特点",
    "difficulty": 1,
    "categoryName": "编程基础",
    "tagNames": ["Java", "编程语言", "编译原理"],
    "answer": "编译型语言和解释型语言的区别在于：\n\n+   编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。\n+   解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。\n+   典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。"
  },
  {
    "questionTitle": "Python和Java区别是什么？",
    "questionTips": "对比两种常用编程语言的执行机制",
    "difficulty": 1,
    "categoryName": "编程语言",
    "tagNames": ["Java", "Python", "编程语言"],
    "answer": "+   Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行\n+   python是一种解释语言，翻译时会在执行程序的同时进行翻译。"
  },
  {
    "questionTitle": "八种基本的数据类型",
    "questionTips": "回忆Java基本数据类型的特点和范围",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型"],
    "answer": "Java支持数据类型分为两类： 基本数据类型和引用数据类型。\n\n基本数据类型共有8种，可以分为三类：\n\n+   数值型：整数类型（byte、short、int、long）和浮点类型（float、double）\n+   字符型：char\n+   布尔型：boolean\n\n![img](https://cdn.xiaolincoding.com//picgo/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png)\n\n8种基本数据类型的默认值、位数、取值范围，如下表所示：\n\n| 数据类型 | 占用大小（字节） | 位数 | 取值范围 | 默认值 | 描述 |\n| --- | --- | --- | --- | --- | --- |\n| `byte` | 1 | 8 | \\-128（-2^7） 到 127（2^7 - 1） | 0 | 是最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据。 |\n| `short` | 2 | 16 | \\-32768（-2^15） 到 32767（2^15 - 1） | 0 | 较少使用，通常用于在需要节省内存且数值范围在该区间的场景。 |\n| `int` | 4 | 32 | \\-2147483648（-2^31） 到 2147483647（2^31 - 1） | 0 | 最常用的整数类型，可满足大多数日常编程中整数计算的需求。 |\n| `long` | 8 | 64 | \\-9223372036854775808（-2^63） 到 9223372036854775807（2^63 - 1） | 0L | 用于表示非常大的整数，当 `int` 类型无法满足需求时使用，定义时数值后需加 `L` 或 `l`。 |\n| `float` | 4 | 32 | 1.4E - 45 到 3.4028235E38 | 0.0f | 单精度浮点数，用于表示小数，精度相对较低，定义时数值后需加 `F` 或 `f`。 |\n| `double` | 8 | 64 | 4.9E - 324 到 1.7976931348623157E308 | 0.0d | 双精度浮点数，精度比 `float` 高，是 Java 中表示小数的默认类型。 |\n| `char` | 2 | 16 | '\\\\u0000'（0） 到 '\\\\uffff'（65535） | '\\\\u0000' | 用于表示单个字符，采用 Unicode 编码，可表示各种语言的字符。 |\n| `boolean` | 无明确字节大小（理论上 1 位） | 无明确位数 | `true` 或 `false` | `false` | 用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景。 |\n\nFloat和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的\"E+数字\"表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。\n\n注意一下几点：\n\n+   Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)\n+   浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）\n+   整数的默认类型为int（声明Long型在末尾加上l或者L）\n+   八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写\n+   char类型是无符号的，不能为负，所以是0开始的"
  },
  {
    "questionTitle": "int和long是多少位，多少字节的？",
    "questionTips": "记住基本数据类型的存储空间大小",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型"],
    "answer": "+   `int`类型是 32 位（bit），占 4 个字节（byte），int 是有符号整数类型，其取值范围是从 -2^31 到 2^31-1 。例如，在一个简单的计数器程序中，如果使用`int`类型来存储计数值，它可以表示的最大正数是 2,147,483,647。如果计数值超过这个范围，就会发生溢出，导致结果不符合预期。\n+   `long`类型是 64 位，占 8 个字节，`long`类型也是有符号整数类型，它的取值范围是从 -2^63 到 2^63 -1 ，在处理较大的整数数值时，果`int`类型的取值范围不够，就需要使用`long`类型。例如，在一个文件传输程序中，文件的大小可能会很大，使用`int`类型可能无法准确表示，而`long`类型就可以很好地处理这种情况。"
  },
  {
    "questionTitle": "long和int可以互转吗？",
    "questionTips": "考虑数据类型转换的规则和限制",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "类型转换"],
    "answer": "可以的，Java中的`long`和`int`可以相互转换。由于`long`类型的范围比`int`类型大，因此将`int`转换为`long`是安全的，而将`long`转换为`int`可能会导致数据丢失或溢出。\n\n将`int`转换为`long`可以通过直接赋值或强制类型转换来实现。例如：\n\n```text\nint intValue = 10;\nlong longValue = intValue; // 自动转换，安全的\n```\n\n将`long`转换为`int`需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。\n\n![image-20240726003850183](https://cdn.xiaolincoding.com//picgo/image-20240726003850183.png)\n\n例如：\n\n```text\nlong longValue = 100L;\nint intValue = (int) longValue; // 强制类型转换，可能会有数据丢失或溢出\n```\n\n在将`long`转换为`int`时，如果`longValue`的值超出了`int`类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查`longValue`的值是否在`int`类型的范围内，以避免数据丢失或溢出的问题。"
  },
  {
    "questionTitle": "数据类型转换方式你知道哪些？",
    "questionTips": "整理Java中不同类型的数据转换机制",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "类型转换"],
    "answer": "+   自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将`int`转换为`long`、将`float`转换为`double`等。\n+   强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将`long`转换为`int`、将`double`转换为`int`等。语法为：目标类型 变量名 = (目标类型) 源类型。\n+   字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型`int`，可以使用`Integer.parseInt()`方法；将字符串转换为浮点型`double`，可以使用`Double.parseDouble()`方法等。\n+   数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如`Character`类、`Integer`类等提供了相应的转换方法。"
  },
  {
    "questionTitle": "类型互转会出现什么问题吗？",
    "questionTips": "思考数据类型转换过程中可能出现的问题",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "类型转换"],
    "answer": "+   数据丢失：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如，将一个`long`类型的值转换为`int`类型时，如果`long`值超出了`int`类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。\n+   数据溢出：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如，将一个`int`类型的值转换为`long`类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。\n+   精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(`float`)转换为双精度浮点数(`double`)时，精度可能会损失。\n+   类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。"
  },
  {
    "questionTitle": "为什么用BigDecimal不用double？",
    "questionTips": "思考精确数值计算场景下的数据类型选择",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "BigDecimal", "浮点数"],
    "answer": "double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333...)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。\n\n比如：\n\n```java\nSystem.out.println(0.05 + 0.01);\nSystem.out.println(1.0 - 0.42);\nSystem.out.println(4.015 * 100);\nSystem.out.println(123.3 / 100);\n\n输出：\n0.060000000000000005\n0.5800000000000001\n401.49999999999994\n1.2329999999999999\n```\n\n可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。\n\n而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。\n\n```java\nimport java.math.BigDecimal;\n\npublic class BigDecimalExample {\n    public static void main(String[] args) {\n        BigDecimal num1 = new BigDecimal(\"0.1\");\n        BigDecimal num2 = new BigDecimal(\"0.2\");\n\n        BigDecimal sum = num1.add(num2);\n        BigDecimal product = num1.multiply(num2);\n\n        System.out.println(\"Sum: \" + sum);\n        System.out.println(\"Product: \" + product);\n    }\n}\n\n//输出\nSum: 0.3\nProduct: 0.02\n```\n\n在上述代码中，我们创建了两个`BigDecimal`对象`num1`和`num2`，分别表示0.1和0.2这两个十进制数。然后，我们使用`add()`方法计算它们的和，并使用`multiply()`方法计算它们的乘积。最后，我们通过`System.out.println()`打印结果。\n\n这样的使用`BigDecimal`可以确保精确的十进制数值计算，避免了使用`double`可能出现的舍入误差。需要注意的是，在创建`BigDecimal`对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。"
  },
  {
    "questionTitle": "装箱和拆箱是什么？",
    "questionTips": "理解Java中基本类型与包装类的自动转换机制",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "包装类", "自动装箱", "自动拆箱"],
    "answer": "装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。\n\n```text\nInteger i = 10;  //装箱\nint n = i;   //拆箱\n```\n\n自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。\n\n> 赋值时\n\n这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。\n\n```text\n//before autoboxing\nInteger iObject = Integer.valueOf(3);\nInt iPrimitive = iObject.intValue()\n\n//after java5\nInteger iObject = 3; //autobxing - primitive to wrapper conversion\nint iPrimitive = iObject; //unboxing - object to primitive conversion\n```\n\n> 方法调用时\n\n当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。\n\n```java\npublic static Integer show(Integer iParam){\n   System.out.println(\"autoboxing example - method invocation i: \" + iParam);\n   return iParam;\n}\n\n//autoboxing and unboxing in method invocation\nshow(3); //autoboxing\nint result = show(3); //unboxing because return type of method is Integer\n```\n\nshow方法接受Integer对象作为参数，当调用`show(3)`时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而`int result = show(3);`中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。\n\n> 自动装箱的弊端\n\n自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。\n\n```java\nInteger sum = 0; for(int i=1000; i<5000; i++){   sum+=i; } \n```\n\n上面的代码`sum+=i`可以看成`sum = sum + i`，但是`+`这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下\n\n```java\nint result = sum.intValue() + i; Integer sum = new Integer(result); \n```\n\n由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。"
  },
  {
    "questionTitle": "Java为什么要有Integer？",
    "questionTips": "思考基本类型包装类存在的必要性",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "包装类", "Integer"],
    "answer": "Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。\n\n另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。\n\n> 泛型中的应用\n\n在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(3);\nlist.add(1);\nlist.add(2);\nCollections.sort(list);\nSystem.out.println(list);\n```\n\n> 转换中的应用\n\n在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。\n\n```java\nint i = 10;\nInteger integer = new Integer(i);\nString str = integer.toString();\nSystem.out.println(str);\n```\n\n> 集合中的应用\n\nJava集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(3);\nlist.add(1);\nlist.add(2);\nint sum = list.stream().mapToInt(Integer::intValue).sum();\nSystem.out.println(sum);\n```"
  },
  {
    "questionTitle": "Integer相比int有什么优点？",
    "questionTips": "思考引用类型相对基本类型的特点",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "包装类"],
    "answer": "int是Java中的原始数据类型，而Integer是int的包装类。\n\nInteger和 int 的区别：\n\n+   基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。\n+   自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。\n+   空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。"
  },
  {
    "questionTitle": "那为什么还要保留int类型？",
    "questionTips": "思考基本类型存在的价值",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "数据类型", "性能优化"],
    "answer": "包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。\n\n因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。\n\n也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。"
  },
  {
    "questionTitle": "说一下Integer的缓存",
    "questionTips": "了解Integer类的内部优化机制",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "Integer", "缓存机制"],
    "answer": "Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。\n\n默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。"
  },
  {
    "questionTitle": "怎么理解面向对象？简单说说封装继承多态",
    "questionTips": "从编程思想角度理解OOP核心特性",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "封装", "继承", "多态"],
    "answer": "面向对象是一种编程范式，它**将现实世界中的事物抽象为对象**，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。\n\nJava面向对象的三大特性包括：**封装、继承、多态**：\n\n+   **封装**：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。\n+   **继承**：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。\n+   **多态**：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。"
  },
  {
    "questionTitle": "多态体现在哪几个方面？",
    "questionTips": "识别Java中实现多态的不同方式",
    "difficulty": 2,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "多态"],
    "answer": "多态在面向对象编程中可以体现在以下几个方面：\n\n+   **方法重载：**\n    +   方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。\n    +   示例：对于一个 `add` 方法，可以定义为 `add(int a, int b)` 和 `add(double a, double b)`。\n+   **方法重写：**\n    +   方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。\n    +   示例：在一个动物类中，定义一个 `sound` 方法，子类 `Dog` 可以重写该方法以实现 `bark`，而 `Cat` 可以实现 `meow`。\n+   **接口与实现：**\n    +   多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。\n    +   示例：多个类（如 `Dog`, `Cat`）都实现了一个 `Animal` 接口，当用 `Animal` 类型的引用来调用 `makeSound` 方法时，会触发对应的实现。\n+   **向上转型和向下转型：**\n    +   在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。\n    +   向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 `ClassCastException`。"
  },
  {
    "questionTitle": "多态解决了什么问题？",
    "questionTips": "理解多态在面向对象设计中的价值",
    "difficulty": 2,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "多态"],
    "answer": "多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。\n\n多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等"
  },
  {
    "questionTitle": "面向对象的设计原则你知道有哪些吗？",
    "questionTips": "回顾常见的面向对象设计原则",
    "difficulty": 2,
    "categoryName": "设计原则",
    "tagNames": ["Java", "面向对象", "设计原则"],
    "answer": "面向对象编程中的六大原则：\n\n+   **单一职责原则（SRP）**：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。\n+   **开放封闭原则（OCP）**：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。\n+   **里氏替换原则（LSP）**：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。\n+   **接口隔离原则（ISP）**：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。\n+   **依赖倒置原则（DIP）**：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。\n+   **最少知识原则 (Law of Demeter)**：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。"
  },
  {
    "questionTitle": "重载与重写有什么区别？",
    "questionTips": "比较这两种常见的面向对象编程技术",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "重载", "重写"],
    "answer": "+   重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。\n+   重写（Overriding）指的是子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@override注解来明确表示这是对父类方法的重写。\n\n重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。"
  },
  {
    "questionTitle": "抽象类和普通类区别？",
    "questionTips": "理解抽象类的特性及用途",
    "difficulty": 1, 
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "抽象类"],
    "answer": "+   实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。\n+   方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。\n+   继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。\n+   实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。"
  },
  {
    "questionTitle": "Java抽象类和接口的区别是什么？",
    "questionTips": "比较Java中两种不同的抽象机制",
    "difficulty": 2,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "抽象类", "接口"],
    "answer": "**两者的特点：**\n\n+   抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。\n+   接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。\n\n**两者的区别：**\n\n+   实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。\n+   方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。\n+   访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。\n+   变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。"
  },
  {
    "questionTitle": "抽象类能加final修饰吗？",
    "questionTips": "考虑抽象类和final关键字的作用是否冲突",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "抽象类", "final"],
    "answer": "**不能**，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。"
  },
  {
    "questionTitle": "接口里面可以定义哪些方法？",
    "questionTips": "了解Java接口中可定义的方法类型",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "接口"],
    "answer": "+   **抽象方法**\n\n抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。\n\n```java\npublic interface Animal {\n    void makeSound();\n}\n```\n\n+   **默认方法**\n\n默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。\n\n```java\npublic interface Animal {\n    void makeSound();\n    \n    default void sleep() {\n        System.out.println(\"Sleeping...\");\n    }\n}\n```\n\n+   **静态方法**\n\n静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。\n\n```java\npublic interface Animal {\n    void makeSound();\n    \n    static void staticMethod() {\n        System.out.println(\"Static method in interface\");\n    }\n}\n```\n\n+   **私有方法**\n\n私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。\n\n```java\npublic interface Animal {\n    void makeSound();\n    \n    default void sleep() {\n        System.out.println(\"Sleeping...\");\n        logSleep();\n    }\n    \n    private void logSleep() {\n        System.out.println(\"Logging sleep\");\n    }\n}\n```\n\n```java\npublic interface Animal {\n    void makeSound();\n}\n```"
  },
  {
    "questionTitle": "抽象类可以被实例化吗？",
    "questionTips": "思考抽象类的使用限制",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "抽象类"],
    "answer": "在Java中，抽象类本身不能被实例化。\n\n这意味着不能使用`new`关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由`abstract`关键字修饰且无方法体的方法），这些方法需要在子类中被实现。\n\n抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。\n\n例如：\n\n```java\npublic abstract class AbstractClass {\n    public AbstractClass() {\n        // 构造器代码\n    }\n    \n    public abstract void abstractMethod();\n}\n\npublic class ConcreteClass extends AbstractClass {\n    public ConcreteClass() {\n        super(); // 调用抽象类的构造器\n    }\n    \n    @Override\n    public void abstractMethod() {\n        // 实现抽象方法\n    }\n}\n\n// 下面的代码可以运行\nConcreteClass obj = new ConcreteClass();\n```\n\n在这个例子中，`ConcreteClass`继承了`AbstractClass`并实现了抽象方法`abstractMethod()`。当我们创建`ConcreteClass`的实例时，`AbstractClass`的构造器被调用，但这并不意味着`AbstractClass`被实例化；实际上，我们创建的是`ConcreteClass`的一个对象。\n\n简而言之，抽象类不能直接实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。"
  },
  {
    "questionTitle": "接口可以包含构造函数吗？",
    "questionTips": "理解接口设计的基本规则",
    "difficulty": 1,
    "categoryName": "面向对象",
    "tagNames": ["Java", "面向对象", "接口"],
    "answer": "在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。\n\n为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用"
  },
  {
    "questionTitle": "解释Java中的静态变量和静态方法",
    "questionTips": "理解静态成员的作用范围和生命周期",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "静态变量", "静态方法"],
    "answer": "在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。\n\n> 静态变量\n\n静态变量（也称为类变量）是在类中使用`static`关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：\n\n+   **共享性**：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。\n+   **初始化**：静态变量在类被加载时初始化，只会对其进行一次分配内存。\n+   **访问方式**：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。\n\n示例：\n\n```text\npublic class MyClass {\n    static int staticVar = 0; // 静态变量\n\n    public MyClass() {\n        staticVar++; // 每创建一个对象，静态变量自增\n    }\n    \n    public static void printStaticVar() {\n        System.out.println(\"Static Var: \" + staticVar);\n    }\n}\n\n// 使用示例\nMyClass obj1 = new MyClass();\nMyClass obj2 = new MyClass();\nMyClass.printStaticVar(); // 输出 Static Var: 2\n```\n\n> 静态方法\n\n静态方法是在类中使用`static`关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：\n\n+   **无实例依赖**：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。\n+   **访问静态成员**：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。\n+   **多态性**：静态方法不支持重写（Override），但可以被隐藏（Hide）。\n\n```text\npublic class MyClass {\n    static int count = 0;\n\n    // 静态方法\n    public static void incrementCount() {\n        count++;\n    }\n\n    public static void displayCount() {\n        System.out.println(\"Count: \" + count);\n    }\n}\n\n// 使用示例\nMyClass.incrementCount(); // 调用静态方法\nMyClass.displayCount();   // 输出 Count: 1\n```\n\n> 使用场景\n\n+   **静态变量**：常用于需要在所有对象间共享的数据，如计数器、常量等。\n+   **静态方法**：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。"
  },
  {
    "questionTitle": "非静态内部类和静态内部类的区别？",
    "questionTips": "理解Java嵌套类的两种不同形式",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "内部类", "静态内部类"],
    "answer": "区别包括：\n\n+   非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。\n+   非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。\n+   非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。\n+   非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。\n+   非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。"
  },
  {
    "questionTitle": "非静态内部类可以直接访问外部方法，编译器是怎么做到的？",
    "questionTips": "了解内部类访问外部类成员的机制",
    "difficulty": 3,
    "categoryName": "Java基础",
    "tagNames": ["Java", "内部类", "编译原理"],
    "answer": "非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。\n\n这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。"
  },
  {
    "questionTitle": "Java 中 final 作用是什么？",
    "questionTips": "理解final关键字在不同场景下的约束作用",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "关键字", "final"],
    "answer": "`final`关键字主要有以下三个方面的作用：用于修饰类、方法和变量。\n\n+   修饰类：当`final`修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的`String`类就是用`final`修饰的，这保证了`String`类的不可变性和安全性，防止其他类通过继承来改变`String`类的行为和特性。\n+   修饰方法：用`final`修饰的方法不能在子类中被重写。比如，`java.lang.Object`类中的`getClass`方法就是`final`的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。\n+   修饰变量：当`final`修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。例如，`final int num = 10;`，这里的`num`就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。对于引用数据类型，`final`修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如，`final StringBuilder sb = new StringBuilder(\"Hello\");`，不能让`sb`再指向其他`StringBuilder`对象，但可以通过`sb.append(\" World\");`来修改字符串的内容。"
  },
  {
    "questionTitle": "深拷贝和浅拷贝的区别？",
    "questionTips": "理解两种不同的对象复制机制",
    "difficulty": 2, 
    "categoryName": "Java基础",
    "tagNames": ["Java", "对象拷贝"],
    "answer": "![img](https://cdn.xiaolincoding.com//picgo/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp)\n\n+   浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。\n+   深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。"
  },
  {
    "questionTitle": "实现深拷贝的三种方法是什么？",
    "questionTips": "掌握常见的对象深拷贝技术",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "对象拷贝", "深拷贝"],
    "answer": "在 Java 中，实现对象深拷贝的方法有以下几种主要方式：\n\n> 实现 Cloneable 接口并重写 clone() 方法\n\n这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。\n\n```java\nclass MyClass implements Cloneable {\n    private String field1;\n    private NestedClass nestedObject;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        MyClass cloned = (MyClass) super.clone();\n        cloned.nestedObject = (NestedClass) nestedObject.clone(); // 深拷贝内部的引用对象\n        return cloned;\n    }\n}\n\nclass NestedClass implements Cloneable {\n    private int nestedField;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n```\n\n> 使用序列化和反序列化\n\n通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。\n\n```java\nimport java.io.*;\n\nclass MyClass implements Serializable {\n    private String field1;\n    private NestedClass nestedObject;\n\n    public MyClass deepCopy() {\n        try {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bos);\n            oos.writeObject(this);\n            oos.flush();\n            oos.close();\n\n            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(bis);\n            return (MyClass) ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n\nclass NestedClass implements Serializable {\n    private int nestedField;\n}\n```\n\n> 手动递归复制\n\n针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。\n\n```java\nclass MyClass {\n    private String field1;\n    private NestedClass nestedObject;\n\n    public MyClass deepCopy() {\n        MyClass copy = new MyClass();\n        copy.setField1(this.field1);\n        copy.setNestedObject(this.nestedObject.deepCopy());\n        return copy;\n    }\n}\n\nclass NestedClass {\n    private int nestedField;\n\n    public NestedClass deepCopy() {\n        NestedClass copy = new NestedClass();\n        copy.setNestedField(this.nestedField);\n        return copy;\n    }\n}\n```"
  },
  {
    "questionTitle": "什么是泛型？",
    "questionTips": "理解Java泛型的设计目的和使用场景",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "泛型"],
    "answer": "泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。\n\n泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。\n\n> 为什么需要泛型？\n\n+   **适用于多种数据类型执行相同的代码**\n\n```java\nprivate static int add(int a, int b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a + b));\n    return a + b;\n}\n\nprivate static float add(float a, float b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a + b));\n    return a + b;\n}\n\nprivate static double add(double a, double b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a + b));\n    return a + b;\n}\n```\n\n如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\n\n```java\nprivate static <T extends Number> double add(T a, T b) {\n    System.out.println(a + \"+\" + b + \"=\" + (a.doubleValue() + b.doubleValue()));\n    return a.doubleValue() + b.doubleValue();\n}\n```\n\n+   **泛型中的类型在使用时指定，不需要强制类型转换**（**类型安全**，编译器会**检查类型**）\n\n看下这个例子：\n\n```java\nList list = new ArrayList();\nlist.add(\"xxString\");\nlist.add(100d);\nlist.add(new Person());\n```\n\n我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。\n\n引入泛型，它将提供类型的约束，提供编译前的检查：\n\n```java\nList<String> list = new ArrayList<String>();\n\n// list中只能放String, 不能放其它类型的元素\n```"
  },
  {
    "questionTitle": "java创建对象有哪些方式？",
    "questionTips": "了解Java中创建对象的多种方法",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "对象创建"],
    "answer": "在Java中，创建对象的方式有多种，常见的包括：\n\n**使用new关键字**：通过new关键字直接调用类的构造方法来创建对象。\n\n```java\nMyClass obj = new MyClass();\n```\n\n**使用Class类的newInstance()方法**：通过反射机制，可以使用Class类的newInstance()方法创建对象。\n\n```java\nMyClass obj = (MyClass) Class.forName(\"com.example.MyClass\").newInstance();\n```\n\n**使用Constructor类的newInstance()方法**：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。\n\n```java\nConstructor<MyClass> constructor = MyClass.class.getConstructor();\nMyClass obj = constructor.newInstance();\n```\n\n**使用clone()方法**：如果类实现了Cloneable接口，可以使用clone()方法复制对象。\n\n```java\nMyClass obj1 = new MyClass();\nMyClass obj2 = (MyClass) obj1.clone();\n```\n\n**使用反序列化**：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。\n\n```java\n// SerializedObject.java\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"object.ser\"));\nout.writeObject(obj);\nout.close();\n\n// DeserializedObject.java\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"object.ser\"));\nMyClass obj = (MyClass) in.readObject();\nin.close();\n```"
  },
  {
    "questionTitle": "Java创建对象除了new还有别的什么方式？",
    "questionTips": "探索不使用new关键字创建对象的方法",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "对象创建", "反射"],
    "answer": "+   **通过反射创建对象**：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。\n\n```java\npublic class MyClass {\n    public MyClass() {\n        // Constructor\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = MyClass.class;\n        MyClass obj = (MyClass) clazz.newInstance();\n    }\n}\n```\n\n+   **通过反序列化创建对象**：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。\n\n```java\nimport java.io.*;\n\npublic class MyClass implements Serializable {\n    // Class definition\n}\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Serialize object\n        MyClass obj = new MyClass();\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"object.ser\"));\n        out.writeObject(obj);\n        out.close();\n        \n        // Deserialize object\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"object.ser\"));\n        MyClass newObj = (MyClass) in.readObject();\n        in.close();\n    }\n}\n```\n\n+   **通过clone创建对象**：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。\n\n```java\npublic class MyClass implements Cloneable {\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        MyClass obj1 = new MyClass();\n        MyClass obj2 = (MyClass) obj1.clone();\n    }\n}\n```"
  },
  {
    "questionTitle": "New出的对象什么时候回收？",
    "questionTips": "理解Java中对象的生命周期和垃圾回收机制",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "垃圾回收", "JVM"],
    "answer": "通过过关键字`new`创建的对象，由Java的垃圾回收器（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。\n\n具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：\n\n1.  引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。\n2.  可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。\n3.  终结器（Finalizer）：如果对象重写了`finalize()`方法，垃圾回收器会在回收该对象之前调用`finalize()`方法，对象可以在`finalize()`方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。"
  },
  {
    "questionTitle": "如何获取私有对象？",
    "questionTips": "了解如何访问通常受访问修饰符保护的成员",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "反射", "访问控制"],
    "answer": "在 Java 中，私有对象通常指的是类中被声明为 `private` 的成员变量或方法。由于 `private` 访问修饰符的限制，这些成员只能在其所在的类内部被访问。\n\n不过，可以通过下面两种方式来间接获取私有对象。\n\n+   使用公共访问器方法（getter 方法）：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 `getter` 方法），通过调用这些方法可以安全地获取私有对象。\n\n```java\nclass MyClass {\n    // 私有成员变量\n    private String privateField = \"私有字段的值\";\n\n    // 公共的 getter 方法\n    public String getPrivateField() {\n        return privateField;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyClass obj = new MyClass();\n        // 通过调用 getter 方法获取私有对象\n        String value = obj.getPrivateField();\n        System.out.println(value); \n    }\n}\n```\n\n+   反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 `private` 访问修饰符的限制来获取私有对象。\n\n```java\nimport java.lang.reflect.Field;\n\nclass MyClass {\n    private String privateField = \"私有字段的值\";\n}\n\npublic class Main {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n        MyClass obj = new MyClass();\n        // 获取 Class 对象\n        Class<?> clazz = obj.getClass();\n        // 获取私有字段\n        Field privateField = clazz.getDeclaredField(\"privateField\");\n        // 设置可访问性\n        privateField.setAccessible(true);\n        // 获取私有字段的值\n        String value = (String) privateField.get(obj);\n        System.out.println(value); \n    }\n}\n```"
  },
  {
    "questionTitle": "什么是反射？",
    "questionTips": "理解Java反射机制的基本原理和作用",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "反射"],
    "answer": "Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n反射具有以下特性：\n\n1.  **运行时类信息访问**：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。\n2.  **动态对象创建**：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。\n3.  **动态方法调用**：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。\n4.  **访问和修改字段值**：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。\n\n![img](https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png)"
  },
  {
    "questionTitle": "反射在你平时写代码或者框架中的应用场景有哪些？",
    "questionTips": "思考Java反射在实际开发中的用途",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "反射", "框架"],
    "answer": "> 加载数据库驱动\n\n我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。\n\n这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。\n\n```java\n//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n```\n\n> 配置文件加载\n\nSpring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。\n\nSpring通过XML配置模式装载Bean的过程：\n\n+   将程序中所有XML或properties配置文件加载入内存\n+   Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息\n+   使用反射机制，根据这个字符串获得某个类的Class实例\n+   动态配置实例的属性\n\n配置文件\n\n```java\nclassName=com.example.reflectdemo.TestInvoke\nmethodName=printlnState\n```\n\n实体类\n\n```java\npublic class TestInvoke {\n    private void printlnState(){\n        System.out.println(\"I am fine\");\n    }\n}\n```\n\n解析配置文件内容\n\n```java\n// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息\npublic static String getName(String key) throws IOException {\n    Properties properties = new Properties();\n    FileInputStream in = new FileInputStream(\"D:\\IdeaProjects\\AllDemos\\language-specification\\src\\main\\resources\\application.properties\");\n    properties.load(in);\n    in.close();\n    return properties.getProperty(key);\n}\n```\n\n利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法\n\n```java\npublic static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException {\n    // 使用反射机制，根据这个字符串获得Class对象\n    Class<?> c = Class.forName(getName(\"className\"));\n    System.out.println(c.getSimpleName());\n    // 获取方法\n    Method method = c.getDeclaredMethod(getName(\"methodName\"));\n    // 绕过安全检查\n    method.setAccessible(true);\n    // 创建实例对象\n    TestInvoke testInvoke = (TestInvoke)c.newInstance();\n    // 调用方法\n    method.invoke(testInvoke);\n\n}\n```\n\n运行结果：\n\n![img](https://cdn.xiaolincoding.com//picgo/1718786675327-3a60bcc7-2f70-4096-998e-d6e94f5df6a4.png)"
  },
  {
    "questionTitle": "能讲一讲Java注解的原理吗？",
    "questionTips": "了解Java注解的实现机制",
    "difficulty": 3,
    "categoryName": "Java基础",
    "tagNames": ["Java", "注解"],
    "answer": "注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。\n\n我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。"
  },
  {
    "questionTitle": "对注解解析的底层实现了解吗？",
    "questionTips": "了解Java如何在运行时处理注解信息",
    "difficulty": 3,
    "categoryName": "Java基础",
    "tagNames": ["Java", "注解", "反射"],
    "answer": "注解本质上是一种特殊的接口，它继承自 `java.lang.annotation.Annotation` 接口，**所以注解也叫声明式接口**，例如，定义一个简单的注解：\n\n```java\npublic @interface MyAnnotation {\n    String value();\n}\n```\n\n编译后，Java 编译器会将其转换为一个继承自 `Annotation` 的接口，并生成相应的字节码文件。\n\n根据注解的作用范围，Java 注解可以分为以下几种类型：\n\n+   **源码级别注解** ：仅存在于源码中，编译后不会保留（`@Retention(RetentionPolicy.SOURCE)`）。\n+   **类文件级别注解** ：保留在 `.class` 文件中，但运行时不可见（`@Retention(RetentionPolicy.CLASS)`）。\n+   **运行时注解** ：保留在 `.class` 文件中，并且可以通过反射在运行时访问（`@Retention(RetentionPolicy.RUNTIME)`）。\n\n只有运行时注解可以通过反射机制进行解析。\n\n当注解被标记为 `RUNTIME` 时，Java 编译器会在生成的 `.class` 文件中保存注解信息。这些信息存储在字节码的属性表（Attribute Table）中，具体包括以下内容：\n\n+   **RuntimeVisibleAnnotations** ：存储运行时可见的注解信息。\n+   **RuntimeInvisibleAnnotations** ：存储运行时不可见的注解信息。\n+   **RuntimeVisibleParameterAnnotations** 和 **RuntimeInvisibleParameterAnnotations** ：存储方法参数上的注解信息。\n\n通过工具（如 `javap -v`）可以查看 `.class` 文件中的注解信息。\n\n注解的解析主要依赖于 Java 的反射机制。以下是解析注解的基本流程：\n\n1、获取注册信息：通过反射 API 可以获取类、方法、字段等元素上的注解。例如：\n\n```java\nClass<?> clazz = MyClass.class;\nMyAnnotation annotation = clazz.getAnnotation(MyAnnotation.class);\nif (annotation != null) {\n    System.out.println(annotation.value());\n}\n```\n\n2、底层原理：反射机制的核心类是 `java.lang.reflect.AnnotatedElement`，它是所有可以被注解修饰的元素（如 `Class`、`Method`、`Field` 等）的父接口。该接口提供了以下方法：\n\n+   `getAnnotation(Class<T> annotationClass)`：获取指定类型的注解。\n+   `getAnnotations()`：获取所有注解。\n+   `isAnnotationPresent(Class<? extends Annotation> annotationClass)`：判断是否包含指定注解。\n\n这些方法的底层实现依赖于 JVM 提供的本地方法（Native Method），例如：\n\n+   `native Annotation[] getDeclaredAnnotations0(boolean publicOnly);`\n+   `native <A extends Annotation> A getAnnotation(Class<A> annotationClass);`\n\nJVM 在加载类时会解析 `.class` 文件中的注解信息，并将其存储在内存中，供反射机制使用。\n\n因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 `@Retention` 元注解可以控制注解的保留策略，当使用 `RetentionPolicy.RUNTIME` 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值。"
  },
  {
    "questionTitle": "Java注解的作用域呢？",
    "questionTips": "了解注解可以应用在代码的哪些部分",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "注解"],
    "answer": "注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：\n\n1.  类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。\n2.  方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。\n3.  字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。\n\n除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。"
  },
  {
    "questionTitle": "介绍一下Java异常",
    "questionTips": "理解Java异常体系的基本结构",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "异常处理"],
    "answer": "Java异常类层次结构图：![img](https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp)Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。\n\n1.  **Error（错误）**：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。\n    \n2.  **Exception（异常）**：表示程序本身可以处理的异常条件。异常分为两大类：\n    \n    +   **非运行时异常**：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。\n        \n    +   **运行时异常**：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。"
  },
  {
    "questionTitle": "Java异常处理有哪些？",
    "questionTips": "了解Java异常处理的基本机制",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "异常处理"],
    "answer": "异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：\n\n+   try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。\n\n```java\ntry {\n    // 可能抛出异常的代码\n} catch (ExceptionType1 e1) {\n    // 处理异常类型1的逻辑\n} catch (ExceptionType2 e2) {\n    // 处理异常类型2的逻辑\n} catch (ExceptionType3 e3) {\n    // 处理异常类型3的逻辑\n} finally {\n    // 可选的finally块，用于定义无论是否发生异常都会执行的代码\n}\n```\n\n+   throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。\n\n```text\nthrow new ExceptionType(\"Exception message\");\n```\n\n+   throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。\n\n```java\npublic void methodName() throws ExceptionType {\n    // 方法体\n}\n```\n\n+   finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。\n\n```java\ntry {\n    // 可能抛出异常的代码\n} catch (ExceptionType e) {\n    // 处理异常的逻辑\n} finally {\n    // 无论是否发生异常，都会执行的代码\n}\n```"
  },
  {
    "questionTitle": "抛出异常为什么不用throws？",
    "questionTips": "思考不同异常处理方式的适用场景",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "异常处理"],
    "answer": "如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。\n\n+   **Unchecked Exceptions**：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。\n+   **捕获和处理异常**：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。"
  },
  {
    "questionTitle": "try catch中的语句运行情况",
    "questionTips": "理解异常处理流程",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "异常处理"],
    "answer": "try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。"
  },
  {
    "questionTitle": "try{return \"a\"} fianlly{return \"b\"}这条语句返回啥",
    "questionTips": "理解finally块在异常处理中的执行优先级",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "异常处理", "finally"],
    "answer": "finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回\"b\"。"
  },
  {
    "questionTitle": "== 与 equals 有什么区别？",
    "questionTips": "了解Java中两种不同的比较机制",
    "difficulty": 1,
    "categoryName": "Java基础",
    "tagNames": ["Java", "String", "equals"],
    "answer": "对于字符串变量来说，使用\"==\"和\"equals\"比较字符串时，其比较方法不同。\"==\"比较两个变量本身的值，即两个对象在内存中的首地址，\"equals\"比较字符串包含内容是否相同。\n\n对于非字符串变量来说，如果没有对equals()进行重写的话，\"==\" 和 \"equals\"方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。\n\n+   \\==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；\n+   equals()：比较的是两个字符串的内容，属于内容比较。"
  },
  {
    "questionTitle": "hashcode和equals方法有什么关系？",
    "questionTips": "理解Java中对象相等性和哈希值的关系",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "Object", "hashCode", "equals"],
    "answer": "在 Java 中，对于重写 `equals` 方法的类，通常也需要重写 `hashCode` 方法，并且需要遵循以下规定：\n\n+   **一致性**：如果两个对象使用 `equals` 方法比较结果为 `true`，那么它们的 `hashCode` 值必须相同。也就是说，如果 `obj1.equals(obj2)` 返回 `true`，那么 `obj1.hashCode()` 必须等于 `obj2.hashCode()`。\n+   **非一致性**：如果两个对象的 `hashCode` 值相同，它们使用 `equals` 方法比较的结果不一定为 `true`。即 `obj1.hashCode() == obj2.hashCode()` 时，`obj1.equals(obj2)` 可能为 `false`，这种情况称为哈希冲突。\n\n`hashCode` 和 `equals` 方法是紧密相关的，重写 `equals` 方法时必须重写 `hashCode` 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 `hashCode` 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等。"
  },
  {
    "questionTitle": "String、StringBuffer、StringBuilder的区别和联系",
    "questionTips": "比较Java中三种不同的字符串处理类",
    "difficulty": 2,
    "categoryName": "Java基础",
    "tagNames": ["Java", "String", "StringBuffer", "StringBuilder"],
    "answer": "**1、可变性** ：`String` 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。`StringBuilder` 和 `StringBuffer` 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象。\n\n**2、线程安全性** ：`String` 因为不可变，天然线程安全。`StringBuilder` 不是线程安全的，适用于单线程环境。`StringBuffer` 是线程安全的，其方法通过 `synchronized` 关键字实现同步，适用于多线程环境。\n\n**3、性能** ：`String` 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。`StringBuilder` 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。`StringBuffer` 性能略低于 `StringBuilder`，因为它的线程安全机制引入了同步开销。\n\n**4、使用场景** ：如果字符串内容固定或不常变化，优先使用 `String`。如果需要频繁修改字符串且在单线程环境下，使用 `StringBuilder`。如果需要频繁修改字符串且在多线程环境下，使用 `StringBuffer`。\n\n对比总结如下：\n\n| **特性** | **String** | **StringBuilder** | **StringBuffer** |\n| --- | --- | --- | --- |\n| **不可变性** | 不可变 | 可变 | 可变 |\n| **线程安全** | 是（因不可变） | 否 | 是（同步方法） |\n| **性能** | 低（频繁修改时） | 高（单线程） | 中（多线程安全） |\n| **适用场景** | 静态字符串 | 单线程动态字符串 | 多线程动态字符串 |\n\n例子代码如下：\n\n```java\n// String的不可变性\nString str = \"abc\";\nstr = str + \"def\"; // 新建对象，str指向新对象\n\n// StringBuilder（单线程高效）\nStringBuilder sb = new StringBuilder();\nsb.append(\"abc\").append(\"def\"); // 直接修改内部数组\n\n// StringBuffer（多线程安全）\nStringBuffer sbf = new StringBuffer();\nsbf.append(\"abc\").append(\"def\"); // 同步方法保证线程安全\n```"
  }
]